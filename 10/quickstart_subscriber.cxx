/* quickstart_subscriber.cxx

A subscription example

This file is derived from code automatically generated by the rtiddsgen 
command:

rtiddsgen -language C++11 -example <arch> quickstart.idl

Example subscription of type qs::qs_type automatically generated by 
'rtiddsgen'. To test them, follow these steps:

(1) Compile this file and the example publication.

(2) Start the subscription on the same domain used for RTI Data Distribution
Service  with the command
objs/<arch>/quickstart_subscriber <domain_id> <sample_count>

(3) Start the publication on the same domain used for RTI Data Distribution
Service with the command
objs/<arch>/quickstart_publisher <domain_id> <sample_count>

(4) [Optional] Specify the list of discovery initial peers and 
multicast receive addresses via an environment variable or a file 
(in the current working directory) called NDDS_DISCOVERY_PEERS. 

You can run any number of publishers and subscribers programs, and can 
add and remove them dynamically from the domain.

Example:

To run the example application on domain <domain_id>:

On UNIX systems: 

objs/<arch>/quickstart_publisher <domain_id> 
objs/<arch>/quickstart_subscriber <domain_id> 

On Windows systems:

objs\<arch>\quickstart_publisher <domain_id>  
objs\<arch>\quickstart_subscriber <domain_id>   

*/
#include <algorithm>
#include <iostream>

#include <dds/sub/ddssub.hpp>
#include <dds/core/ddscore.hpp>
// Or simply include <dds/dds.hpp> 

#include "quickstart.hpp"

//  LAB #2 - a.	Fix Reader listener to note Qos Error.
class MyReaderListener : public dds::sub::NoOpDataReaderListener<qs::qs_type> {
    
public:

    MyReaderListener() { }

    // LAB #7 - add the on_data_available method
    void on_data_available(dds::sub::DataReader<qs::qs_type>& reader) {
        // Take all samples
        std::cout << "in the listener" << std::endl; // obviously, don't do this in a production listener
        dds::sub::LoanedSamples<qs::qs_type> samples = reader.take();

        for ( dds::sub::LoanedSamples<qs::qs_type>::iterator sample_it = samples.begin();
        sample_it != samples.end(); sample_it++) {

            if (sample_it->info().valid()){
                count_++;
                std::cout << sample_it->data() << std::endl; 
            }        
        }      
    }

    void on_requested_incompatible_qos(dds::sub::DataReader<qs::qs_type>& reader, 
            const dds::core::status::RequestedIncompatibleQosStatus & status) {

        std::cout << "Incompatible Offered QoS: " << std::endl;
        std::cout << "   Total Count: " << status.total_count() << std::endl;
        std::cout << "   Total Count Change: " << status.total_count_change() << std::endl;
        std::cout << "   Last Policy ID: " << status.last_policy_id() << std::endl;
    }

    int count() const
    {
        return count_;
    }

private:
    int count_;

};


int subscriber_main(int domain_id, int sample_count)
{
    // LAB #6 - Create a (non-default) qosProvider
	std::string qosProfile;
	qosProfile.clear();
	qosProfile.append("MyLibrary").append("::").append("MyProfile");
	dds::core::QosProvider qosProvider("file://MY_QOS_PROFILES.xml", qosProfile);

    // LAB #6 - use our new qsoProvider when creating our entities
    //dds::domain::DomainParticipant participant(domain_id);
	dds::domain::DomainParticipant participant(domain_id, qosProvider.participant_qos());

    // Create a Topic -- and automatically register the type
    // LAB #4 - use a constant defined in the IDL for the Topic name
    dds::topic::Topic<qs::qs_type> topic(participant, qs::topicName);

    // LAB #10 - use a Content Filtered Topic
    // first set up the default parameter of the filter.

    std::vector<std::string> parameters(1);
    parameters[0] = "Don Gochenour"; // this will be the string we look for in each sample
    dds::topic::Filter filter("name MATCH %0", parameters);

    // If there is no filter name, the regular SQL filter will be used.
    filter->name(rti::topic::stringmatch_filter_name());

    dds::topic::ContentFilteredTopic<qs::qs_type>  cft_topic(
                        topic, 
                        "ContentFilteredTopic", 
                        filter);

    // LAB #2 - instantiate listener and create reader with listener

    // Create a DataReader with default Qos (Subscriber created in-line)
    //dds::sub::DataReader<qs::qs_type> reader(dds::sub::Subscriber(participant), topic);

    // LAB #6 - we need to change dds::core::QosProvider::Default() to 
    // qosProvider, which we created above
    MyReaderListener listener;
    
    // LAB #10 - change "topic" to "ContentFilteredTopic"
    // LAB #7 - add data_available to the status mask
    dds::sub::DataReader<qs::qs_type> reader(
            dds::sub::Subscriber(participant, qosProvider.subscriber_qos()), 
            cft_topic, /*topic,*/ 
            qosProvider.datareader_qos(), 
            &listener, 
            dds::core::status::StatusMask::data_available() | dds::core::status::StatusMask::requested_incompatible_qos());

    // Create a ReadCondition for any data on this reader and associate a handler
    int count = 0;
    dds::sub::cond::ReadCondition read_condition(
        reader,
        dds::sub::status::DataState::any(),
        [&reader, &count]()
    {
        // Take all samples
        dds::sub::LoanedSamples<qs::qs_type> samples = reader.take();
        for (auto sample : samples){
            if (sample.info().valid()){
                count++;
                std::cout << sample.data() << std::endl; 
            }   
        }

    } // The LoanedSamples destructor returns the loan
    );

    // Create a WaitSet and attach the ReadCondition
    dds::core::cond::WaitSet waitset;
    waitset += read_condition;

    // LAB #7 - change count to listener.count()
    while (listener.count() < sample_count || sample_count == 0) {
        // Dispatch will call the handlers associated to the WaitSet conditions
        // when they activate
        std::cout << "qs::qs_type subscriber sleeping for 4 sec..." << std::endl;

        waitset.dispatch(dds::core::Duration(4)); // Wait up to 4s each time
    }
    return 1;
}

int main(int argc, char *argv[])
{

    int domain_id = 0;
    int sample_count = 0; // infinite loop

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = atoi(argv[2]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        subscriber_main(domain_id, sample_count);
    } catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in subscriber_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}

